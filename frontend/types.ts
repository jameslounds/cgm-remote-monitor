/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/entries/{spec}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * All Entries matching query
         * @description The Entries endpoint returns information about the
         *     Nightscout entries.
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description The query used to find entries, support nested query syntax, for
                     *     example `find[dateString][$gte]=2015-08-27`.  All find parameters
                     *     are interpreted as strings.
                     *      */
                    find?: string;
                    /** @description Number of entries to return. */
                    count?: number;
                };
                header?: never;
                path: {
                    /** @description entry id, such as `55cf81bc436037528ec75fa5` or a type filter such
                     *     as `sgv`, `mbg`, etc.
                     *      */
                    spec: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Entries"];
                    };
                };
                /** @description Entries */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Entries"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/slice/{storage}/{field}/{type}/{prefix}/{regex}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * All Entries matching query
         * @description The Entries endpoint returns information about the Nightscout entries.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The query used to find entries, support nested query syntax, for
                     *     example `find[dateString][$gte]=2015-08-27`.  All find parameters
                     *     are interpreted as strings.
                     *      */
                    find?: string;
                    /** @description Number of entries to return. */
                    count?: number;
                };
                header?: never;
                path: {
                    /** @description Prefix to use in constructing a prefix-based regex, default is `entries`. */
                    storage: string;
                    /** @description Name of the field to use Regex against in query object, default is `dateString`. */
                    field: string;
                    /** @description The type field to search against, default is sgv. */
                    type: string;
                    /** @description Prefix to use in constructing a prefix-based regex. */
                    prefix: string;
                    /** @description Tail part of regexp to use in expanding/construccting a query object.
                     *     Regexp also has bash-style brace and glob expansion applied to it,
                     *     creating ways to search for modal times of day, perhaps using
                     *     something like this syntax: `T{15..17}:.*`, this would search for
                     *     all records from 3pm to 5pm.
                     *      */
                    regex: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Entries"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/echo/{storage}/{spec}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * View generated Mongo Query object
         * @description Information about the mongo query object created by the query.
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description The query used to find entries, support nested query syntax, for
                     *     example `find[dateString][$gte]=2015-08-27`.  All find parameters
                     *     are interpreted as strings.
                     *      */
                    find?: string;
                    /** @description Number of entries to return. */
                    count?: number;
                };
                header?: never;
                path: {
                    /** @description `entries`, or `treatments` to select the storage layer.
                     *      */
                    storage: string;
                    /** @description entry id, such as `55cf81bc436037528ec75fa5` or a type filter such
                     *     as `sgv`, `mbg`, etc.
                     *     This parameter is optional.
                     *      */
                    spec: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MongoQuery"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/times/echo/{prefix}/{regex}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Echo the query object to be used.
         * @description Echo debug information about the query object constructed.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The query used to find entries, support nested query syntax, for example `find[dateString][$gte]=2015-08-27`.  All find parameters are interpreted as strings. */
                    find?: string;
                    /** @description Number of entries to return. */
                    count?: number;
                };
                header?: never;
                path: {
                    /** @description Prefix to use in constructing a prefix-based regex. */
                    prefix: string;
                    /** @description Tail part of regexp to use in expanding/construccting a query object.
                     *     Regexp also has bash-style brace and glob expansion applied to it,
                     *     creating ways to search for modal times of day, perhaps using
                     *     something like this syntax: `T{15..17}:.*`, this would search for
                     *     all records from 3pm to 5pm.
                     *      */
                    regex: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MongoQuery"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/times/{prefix}/{regex}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * All Entries matching query
         * @description The Entries endpoint returns information about the Nightscout entries.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The query used to find entries, support nested query syntax, for example `find[dateString][$gte]=2015-08-27`.  All find parameters are interpreted as strings. */
                    find?: string;
                    /** @description Number of entries to return. */
                    count?: number;
                };
                header?: never;
                path: {
                    /** @description Prefix to use in constructing a prefix-based regex. */
                    prefix: string;
                    /** @description Tail part of regexp to use in expanding/construccting a query object.
                     *     Regexp also has bash-style brace and glob expansion applied to it,
                     *     creating ways to search for modal times of day, perhaps using
                     *     something like this syntax: `T{15..17}:.*`, this would search for
                     *     all records from 3pm to 5pm.
                     *      */
                    regex: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Entries"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/entries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * All Entries matching query
         * @description The Entries endpoint returns information about the Nightscout entries.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The query used to find entries, support nested query syntax, for example `find[dateString][$gte]=2015-08-27`.  All find parameters are interpreted as strings. */
                    find?: string;
                    /** @description Number of entries to return. */
                    count?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Entries"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        /** Add new entries. */
        post: operations["addEntries"];
        /**
         * Delete entries matching query.
         * @description Remove entries, same search syntax as GET.
         */
        delete: operations["remove"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/treatments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Treatments
         * @description The Treatments endpoint returns information about the Nightscout treatments.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The query used to find entries, supports nested query syntax.  Examples `find[insulin][$gte]=3` `find[carb][$gte]=100` `find[eventType]=Correction+Bolus` All find parameters are interpreted as strings. */
                    find?: string;
                    /** @description Number of entries to return. */
                    count?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of treatments */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Treatments"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        /** Add new treatments. */
        post: operations["addTreatments"];
        /**
         * Delete treatments matching query.
         * @description Remove treatments, same search syntax as GET.
         */
        delete: operations["remove"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/treatments/{spec}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete treatments record with id provided in spec
         * @description The Treatments endpoint returns information about the
         *     Nightscout devicestatus records.
         *
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description treatment id, such as `55cf81bc436037528ec75fa5`
                     *      */
                    spec: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A status record of the delete. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DeleteStatus"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Profile
         * @description The Profile endpoint returns information about the Nightscout Treatment Profiles.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of treatments */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Profile"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Status
         * @description Server side status, default settings and capabilities.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Server capabilities and status. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Status"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/devicestatus/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * All Devicestatuses matching query
         * @description The Devicestatus endpoint returns information about the Nightscout devicestatus records.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The query used to find entries, support nested query syntax, for example `find[dateString][$gte]=2015-08-27`.  All find parameters are interpreted as strings. */
                    find?: string;
                    /** @description Number of devicestatus records to return. */
                    count?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of devicestatus entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Devicestatuses"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        /** Add new devicestatus records. */
        post: operations["addDevicestatuses"];
        /**
         * Delete all Devicestatus records matching query
         * @description The Devicestatus endpoint returns information about the
         *     Nightscout devicestatus records.
         *
         */
        delete: {
            parameters: {
                query?: {
                    /** @description The query used to find entries, support nested query syntax, for
                     *     example `find[created_at][$gte]=2015-08-27`.  All find parameters
                     *     are interpreted as strings.
                     *      */
                    find?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A status record of the delete. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DeleteStatus"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/devicestatus/{spec}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete devicestatus record with id provided in spec
         * @description The Devicestatus endpoint returns information about the
         *     Nightscout devicestatus records.
         *
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description entry id, such as `55cf81bc436037528ec75fa5`
                     *      */
                    spec: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A status record of the delete. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DeleteStatus"];
                    };
                };
                /** @description Unexpected error */
                default: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Entry: {
            /** @description sgv, mbg, cal, etc */
            type?: string;
            /** @description dateString, MUST be ISO `8601` format date parseable by Javascript Date() */
            dateString?: string;
            /** @description Epoch */
            date?: number;
            /** @description The glucose reading. (only available for sgv types) */
            sgv?: number;
            /** @description Direction of glucose trend reported by CGM. (only available for sgv types) */
            direction?: string;
            /** @description Noise level at time of reading. (only available for sgv types) */
            noise?: number;
            /** @description The raw filtered value directly from CGM transmitter. (only available for sgv types) */
            filtered?: number;
            /** @description The raw unfiltered value directly from CGM transmitter. (only available for sgv types) */
            unfiltered?: number;
            /** @description The signal strength from CGM transmitter. (only available for sgv types) */
            rssi?: number;
        };
        Entries: components["schemas"]["Entry"][];
        Devicestatus: {
            /** @description Device type and hostname for example openaps://hostname */
            device: string;
            /** @description dateString, prefer ISO `8601` */
            created_at: string;
            /** @description OpenAPS devicestatus record - TODO: Fill Out Details */
            openaps?: string;
            /** @description Loop devicestatus record - TODO: Fill Out Details */
            loop?: string;
            pump?: components["schemas"]["pump"];
            uploader?: components["schemas"]["uploader"];
            xdripjs?: components["schemas"]["xdripjs"];
        };
        Devicestatuses: components["schemas"]["Devicestatus"][];
        pump: {
            /** @description dateString, prefer ISO `8601` */
            clock?: string;
            battery?: components["schemas"]["pumpbattery"];
            /** @description Amount of insulin remaining in pump reservoir */
            reservoir?: number;
            status?: components["schemas"]["pumpstatus"];
        };
        pumpbattery: {
            /** @description Pump Battery Status String */
            status?: string;
            /** @description Pump Battery Voltage Level */
            voltage?: number;
        };
        pumpstatus: {
            /** @description Pump Status String */
            status?: string;
            /** @description Is Pump Bolusing */
            bolusing?: boolean;
            /** @description Is Pump Suspended */
            suspended?: boolean;
            /** @description dateString, prefer ISO `8601` */
            timestamp?: string;
        };
        uploader: {
            /** @description Uploader Device Battery Voltage */
            batteryVoltage?: number;
            /** @description Uploader Device Battery Percentage Charge Remaining */
            battery?: number;
        };
        xdripjs: {
            /** @description CGM Sensor Session State Code */
            state?: number;
            /** @description CGM Sensor Session State String */
            stateString?: string;
            /** @description CGM Sensor Session State Short String */
            stateStringShort?: string;
            /** @description CGM Transmitter ID */
            txId?: string;
            /** @description CGM Transmitter Status */
            txStatus?: number;
            /** @description CGM Transmitter Status String */
            txStatusString?: string;
            /** @description CGM Transmitter Status Short String */
            txStatusStringShort?: string;
            /** @description CGM Transmitter Activation Milliseconds After Epoch */
            txActivation?: number;
            /** @description Mode xdrip-js Application Operationg: expired, not expired, etc. */
            mode?: string;
            /** @description Last Update Milliseconds After Epoch */
            timestamp?: number;
            /** @description Receive Signal Strength of Transmitter */
            rssi?: number;
            /** @description Most Recent Raw Unfiltered Glucose */
            unfiltered?: number;
            /** @description Most Recent Raw Filtered Glucose */
            filtered?: number;
            /** @description Calculated Noise Value - 1=Clean, 2=Light, 3=Medium, 4=Heavy */
            noise?: number;
            /** @description Noise Value String */
            noiseString?: number;
            /** @description Calibration Slope Value */
            slope?: number;
            /** @description Calibration Intercept Value */
            intercept?: number;
            /** @description Algorithm Used to Calculate Calibration Values */
            calType?: string;
            /** @description Most Recent Calibration Milliseconds After Epoch */
            lastCalibrationDate?: number;
            /** @description Sensor Session Start Milliseconds After Epoch */
            sessionStart?: number;
            /** @description Most Recent Batter Status Read Milliseconds After Epoch */
            batteryTimestamp?: number;
            /** @description Voltage of Battery A */
            voltagea?: number;
            /** @description Voltage of Battery B */
            voltageb?: number;
            /** @description Transmitter Temperature */
            temperature?: number;
            /** @description Sensor Resistance */
            resistance?: number;
        };
        Treatment: {
            /** @description Internally assigned id. */
            _id?: string;
            /** @description The type of treatment event. */
            eventType?: string;
            /** @description The date of the event, might be set retroactively . */
            created_at?: string;
            /** @description Current glucose. */
            glucose?: string;
            /** @description Method used to obtain glucose, Finger or Sensor. */
            glucoseType?: string;
            /** @description  Amount of carbs consumed in grams. */
            carbs?: number;
            /** @description  Amount of protein consumed in grams. */
            protein?: number;
            /** @description  Amount of fat consumed in grams. */
            fat?: number;
            /** @description Amount of insulin, if any. */
            insulin?: number;
            /** @description The units for the glucose value, mg/dl or mmol. */
            units?: string;
            /** @description The transmitter ID of the transmitter being started. */
            transmitterId?: string;
            /** @description The code used to start a Dexcom G6 sensor. */
            sensorCode?: string;
            /** @description Description/notes of treatment. */
            notes?: string;
            /** @description Who entered the treatment. */
            enteredBy?: string;
        };
        Treatments: components["schemas"]["Treatment"][];
        Profile: {
            /** @description Internally assigned id */
            sens?: number;
            /** @description Internally assigned id */
            dia?: number;
            /** @description Internally assigned id */
            carbratio?: number;
            /** @description Internally assigned id */
            carbs_hr?: number;
            /** @description Internally assigned id */
            _id?: string;
        };
        Status: {
            /** @description Whether or not the REST API is enabled. */
            apiEnabled?: boolean;
            /** @description Whether or not the careportal is enabled in the API. */
            careportalEnabled?: boolean;
            /** @description The git identifier for the running instance of the app. */
            head?: string;
            /** @description Nightscout (static) */
            name?: string;
            /** @description The version label of the app. */
            version?: string;
            settings?: components["schemas"]["Settings"];
            extendedSettings?: components["schemas"]["ExtendedSettings"];
        };
        Settings: {
            /** @description Default units for glucose measurements across the server. */
            units?: string;
            /**
             * @description Default time format
             * @enum {string}
             */
            timeFormat?: 12 | 24;
            /** @description Default custom title to be displayed system wide. */
            customTitle?: string;
            /** @description Should Night mode be enabled by default? */
            nightMode?: boolean;
            /** @description Default theme to be displayed system wide, `default`, `colors`, `colorblindfriendly`. */
            theme?: string;
            /** @description Default language code to be used system wide */
            language?: string;
            /** @description Plugins that should be shown by default */
            showPlugins?: string;
            /** @description If Raw BG is enabled when should it be shown? `never`, `always`, `noise` */
            showRawbg?: string;
            /**
             * @description Enabled alarm types, can be multiple
             * @enum {array}
             */
            alarmTypes?: "simple" | "predict";
            /** @description Enable/Disable client-side Urgent High alarms by default, for use with `simple` alarms. */
            alarmUrgentHigh?: boolean;
            /** @description Enable/Disable client-side High alarms by default, for use with `simple` alarms. */
            alarmHigh?: boolean;
            /** @description Enable/Disable client-side Low alarms by default, for use with `simple` alarms. */
            alarmLow?: boolean;
            /** @description Enable/Disable client-side Urgent Low alarms by default, for use with `simple` alarms. */
            alarmUrgentLow?: boolean;
            /** @description Enable/Disable client-side stale data alarms by default. */
            alarmTimeagoWarn?: boolean;
            /** @description Number of minutes before a stale data warning is generated. */
            alarmTimeagoWarnMins?: number;
            /** @description Enable/Disable client-side urgent stale data alarms by default. */
            alarmTimeagoUrgent?: boolean;
            /** @description Number of minutes before a stale data warning is generated. */
            alarmTimeagoUrgentMins?: number;
            /** @description Enabled features */
            enable?: string[];
            thresholds?: components["schemas"]["Threshold"];
        };
        Threshold: {
            /** @description High BG range. */
            bg_high?: number;
            /** @description Top of target range. */
            bg_target_top?: number;
            /** @description Bottom of target range. */
            bg_target_bottom?: number;
            /** @description Low BG range. */
            bg_low?: number;
        };
        /** @description Extended settings of client side plugins */
        ExtendedSettings: unknown;
        /** @description Mongo Query object. */
        MongoQuery: unknown;
        Error: {
            /** Format: int32 */
            code?: number;
            message?: string;
            fields?: Record<string, never>;
        };
        DeleteStatus: {
            /**
             * Format: int32
             * @description Number of records deleted
             */
            n?: number;
            optime?: components["schemas"]["optime"];
            /** @description Election id of operation */
            electionId?: string;
            /**
             * Format: int32
             * @description Status of whether delete was successful
             */
            ok?: number;
            /** @description Time delete operation was executed */
            operationTime?: string;
            /** @description Information about execution time in cluster environment */
            $clusterTime?: string;
        };
        optime: {
            /** @description Time the operation started */
            ts?: string;
            /**
             * Format: int32
             * @description Time the operation took to complete
             */
            t?: number;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    addEntries: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Entries to be uploaded. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Entries"];
                "text/plain": components["schemas"]["Entries"];
            };
        };
        responses: {
            /** @description Rejected list of entries.  Empty list is success. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid input */
            405: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    addTreatments: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Treatments to be uploaded. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Treatments"];
            };
        };
        responses: {
            /** @description Rejected list of treatments.  Empty list is success. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid input */
            405: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    remove: {
        parameters: {
            query?: {
                /** @description The query used to find entries, support nested query syntax, for example `find[dateString][$gte]=2015-08-27`.  All find parameters are interpreted as strings. */
                find?: string;
                /** @description Number of entries to return. */
                count?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Empty list is success. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    addDevicestatuses: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Device statuses to be uploaded. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Devicestatuses"];
            };
        };
        responses: {
            /** @description Rejected list of device statuses.  Empty list is success. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid input */
            405: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
